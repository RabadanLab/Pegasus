<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_30) on Sun Jan 15 10:17:01 EST 2012 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
JDBCPreparedStatement (HSQLDB 2.2.7 API)
</TITLE>

<META NAME="date" CONTENT="2012-01-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../javadoc.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JDBCPreparedStatement (HSQLDB 2.2.7 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JDBCPreparedStatement.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/hsqldb/jdbc/JDBCParameterMetaData.html" title="class in org.hsqldb.jdbc"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/hsqldb/jdbc/JDBCResultSet.html" title="class in org.hsqldb.jdbc"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/hsqldb/jdbc/JDBCPreparedStatement.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JDBCPreparedStatement.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.hsqldb.jdbc</FONT>
<BR>
Class JDBCPreparedStatement</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.hsqldb.jdbc.JDBCPreparedStatement</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.sql.PreparedStatement, java.sql.Statement, java.sql.Wrapper</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../org/hsqldb/jdbc/JDBCCallableStatement.html" title="class in org.hsqldb.jdbc">JDBCCallableStatement</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>JDBCPreparedStatement</B><DT>extends java.lang.Object<DT>implements java.sql.PreparedStatement</DL>
</PRE>

<P>
<!-- start generic documentation -->

 An object that represents a precompiled SQL statement.
 <P>A SQL statement is precompiled and stored in a
 <code>PreparedStatement</code> object. This object can then be used to
 efficiently execute this statement multiple times.

 <P><B>Note:</B> The setter methods (<code>setShort</code>, <code>setString</code>,
 and so on) for setting IN parameter values
 must specify types that are compatible with the defined SQL type of
 the input parameter. For instance, if the IN parameter has SQL type
 <code>INTEGER</code>, then the method <code>setInt</code> should be used.

 <p>If arbitrary parameter type conversions are required, the method
 <code>setObject</code> should be used with a target SQL type.
 <P>
 In the following example of setting a parameter, <code>con</code> represents
 an active connection:
 <PRE>
   PreparedStatement pstmt = con.prepareStatement("UPDATE EMPLOYEES
                                     SET SALARY = ? WHERE ID = ?");
   pstmt.setBigDecimal(1, 153833.00)
   pstmt.setInt(2, 110592)
 </PRE>

 <!-- end generic documentation -->

 <!-- start Release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From version 2.0, the implementation meets the JDBC specification
 requirment that any existing ResultSet is closed when execute() or
 executeQuery() methods are called.
 <p>
 JDBCPreparedStatement objects are backed by
 a true compiled parameteric representation. Hence, there are now significant
 performance gains to be had by using a JDBCPreparedStatement object in
 preference to a JDBCStatement object when a short-running SQL statement is
 to be executed more than once. <p>

 When it can be otherwise avoided, it should be considered poor practice to
 fully prepare (construct), parameterize, execute, fetch and close a
 JDBCParameterMetaData object for each execution cycle. Indeed,
 because the prepare and execute phases
 both represent a round-trip to the engine, this practice is likely to be
 noticably <em>less</em> performant for short-running statements (and
 possibly even orders of magnitude less performant over network connections
 for short-running statements) than the equivalent process using JDBCStatement
 objects, albeit far more convenient, less error prone and certainly much
 less resource-intensive, especially when large binary and character values
 are involved, due to the optimized parameterization facility. <p>

 Instead, when developing an application that is not totally oriented toward
 the execution of ad hoc SQL, it is recommended to expend some effort toward
 identifing the SQL statements that are good candidates for regular reuse and
 adapting the structure of the application accordingly. Often, this is done
 by recording the text of candidate SQL statements in an application resource
 object (which has the nice side-benefit of isolating and hiding differences
 in SQL dialects across different drivers) and caching for possible reuse the
 PreparedStatement objects derived from the recorded text. <p>

 Starting with 2.0, when built under a JDBC 4 environment, statement caching
 can be transparently enabled or disabled on a statement-by-statement basis by
 invoking setPoolable(true | false), respectively, upon Statement objects of
 interest. <p>

 <b>Multi thread use:</b> <p>

 A PreparedStatement object is stateful and should not normally be shared
 by multiple threads. If it has to be shared, the calls to set the
 parameters, calls to add batch statements, the execute call and any
 post-execute calls should be made within a block synchronized on the
 PreparedStatement Object.<p>

 <b>JRE 1.1.x Notes:</b> <p>

 In general, JDBC 2 support requires Java 1.2 and above, and JDBC3 requires
 Java 1.4 and above. In HSQLDB, support for methods introduced in different
 versions of JDBC depends on the JDK version used for compiling and building
 HSQLDB.<p>

 Since 1.7.0, all JDBC 2 methods can be called while executing under the
 version 1.1.x
 <em>Java Runtime Environment</em><sup><font size="-2">TM</font></sup>.
 However, in addition to this technique requiring explicit casts to the
 org.hsqldb.jdbc.* classes, some of these method calls require
 <code>int</code> values that are defined only in the JDBC 2 or greater
 version of the <CODE>ResultSet</CODE> interface.  For this
 reason these values are defined in <A HREF="../../../org/hsqldb/jdbc/JDBCResultSet.html" title="class in org.hsqldb.jdbc"><CODE>JDBCResultSet</CODE></A>.<p>

 In a JRE 1.1.x environment, calling JDBC 2 methods that take or return the
 JDBC2-only <code>ResultSet</code> values can be achieved by referring
 to them in parameter specifications and return value comparisons,
 respectively, as follows: <p>

 <pre class="JavaCodeExample">
 JDBCResultSet.FETCH_FORWARD
 JDBCResultSet.TYPE_FORWARD_ONLY
 JDBCResultSet.TYPE_SCROLL_INSENSITIVE
 JDBCResultSet.CONCUR_READ_ONLY
 //etc.
 </pre> <p>

 However, please note that code written to use HSQLDB JDBC 2 features under
 JDK 1.1.x will not be compatible for use with other JDBC 2 drivers. Please
 also note that this feature is offered solely as a convenience to developers
 who must work under JDK 1.1.x due to operating constraints, yet wish to
 use some of the more advanced features available under the JDBC 2
 specification. <p>

 (fredt@users)<br>
 (boucherb@users)<p>

 </div>
 <!-- end release-specific documentation -->
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.7.2</DD>
<DT><B>Author:</B></DT>
  <DD>Campbell Boucher-Burnet (boucherb@users dot sourceforge.net), Fred Toussi (fredt@users dot sourceforge.net)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCConnection.html#prepareStatement(java.lang.String)"><CODE>JDBCConnection.prepareStatement(java.lang.String)</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/JDBCResultSet.html" title="class in org.hsqldb.jdbc"><CODE>JDBCResultSet</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.sql.Statement"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface java.sql.Statement</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>CLOSE_ALL_RESULTS, CLOSE_CURRENT_RESULT, EXECUTE_FAILED, KEEP_CURRENT_RESULT, NO_GENERATED_KEYS, RETURN_GENERATED_KEYS, SUCCESS_NO_INFO</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#addBatch()">addBatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#addBatch(java.lang.String)">addBatch</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#cancel()">cancel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancels this <code>Statement</code> object if both the DBMS and
 driver support aborting an SQL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#clearBatch()">clearBatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empties this <code>Statement</code> object's current list of
 SQL commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#clearParameters()">clearParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the current parameter values immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#clearWarnings()">clearWarnings</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears all the warnings reported on this <code>Statement</code>
 object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the specialized work required to free this object's resources and
 that of it's parent class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#closeOnCompletion()">closeOnCompletion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that this <code>Statement</code> will be closed when all its
 dependent result sets are closed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute()">execute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the SQL statement in this <code>PreparedStatement</code> object,
 which may be any kind of SQL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute(java.lang.String)">execute</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute(java.lang.String, int)">execute</A></B>(java.lang.String&nbsp;sql,
        int&nbsp;autoGeneratedKeys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute(java.lang.String, int[])">execute</A></B>(java.lang.String&nbsp;sql,
        int[]&nbsp;columnIndexes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute(java.lang.String, java.lang.String[])">execute</A></B>(java.lang.String&nbsp;sql,
        java.lang.String[]&nbsp;columnNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeBatch()">executeBatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeQuery()">executeQuery</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeQuery(java.lang.String)">executeQuery</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeUpdate()">executeUpdate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the SQL statement in this <code>PreparedStatement</code> object,
 (JDBC4 clarification:)
 which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
 <code>DELETE</code>; or an SQL statement that returns nothing,
 such as a DDL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeUpdate(java.lang.String)">executeUpdate</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeUpdate(java.lang.String, int)">executeUpdate</A></B>(java.lang.String&nbsp;sql,
              int&nbsp;autoGeneratedKeys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Statement methods that must be overridden in this class and throw
 an exception.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeUpdate(java.lang.String, int[])">executeUpdate</A></B>(java.lang.String&nbsp;sql,
              int[]&nbsp;columnIndexes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#executeUpdate(java.lang.String, java.lang.String[])">executeUpdate</A></B>(java.lang.String&nbsp;sql,
              java.lang.String[]&nbsp;columnNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Connection</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getConnection()">getConnection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>Connection</code> object
 that produced this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getFetchDirection()">getFetchDirection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the direction for fetching rows from
 database tables that is the default for result sets
 generated from this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getFetchSize()">getFetchSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the number of result set rows that is the default
 fetch size for <code>ResultSet</code> objects
 generated from this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getGeneratedKeys()">getGeneratedKeys</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves any auto-generated keys created as a result of executing this
 <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMaxFieldSize()">getMaxFieldSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the maximum number of bytes that can be
 returned for character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMaxRows()">getMaxRows</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the maximum number of rows that a
 <code>ResultSet</code> object produced by this
 <code>Statement</code> object can contain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSetMetaData</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMetaData()">getMetaData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMoreResults()">getMoreResults</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves to this <code>Statement</code> object's next result, returns
 <code>true</code> if it is a <code>ResultSet</code> object, and
 implicitly closes any current <code>ResultSet</code>
 object(s) obtained with the method <code>getResultSet</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMoreResults(int)">getMoreResults</A></B>(int&nbsp;current)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves to this <code>Statement</code> object's next result, deals with
 any current <code>ResultSet</code> object(s) according  to the instructions
 specified by the given flag, and returns
 <code>true</code> if the next result is a <code>ResultSet</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ParameterMetaData</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getParameterMetaData()">getParameterMetaData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the number, types and properties of this
 <code>PreparedStatement</code> object's parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getQueryTimeout()">getQueryTimeout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the number of seconds the driver will
 wait for a <code>Statement</code> object to execute.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getResultSet()">getResultSet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current result as a <code>ResultSet</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getResultSetConcurrency()">getResultSetConcurrency</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the result set concurrency for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getResultSetHoldability()">getResultSetHoldability</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the result set holdability for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getResultSetType()">getResultSetType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the result set type for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getUpdateCount()">getUpdateCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current result as an update count;
  if the result is a <code>ResultSet</code> object or there are no more results, -1
  is returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.SQLWarning</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getWarnings()">getWarnings</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the first warning reported by calls on this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#isClosed()">isClosed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves whether this <code>Statement</code> object has been closed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#isCloseOnCompletion()">isCloseOnCompletion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a value indicating whether this <code>Statement</code> will be
 closed when all its dependent result sets are closed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#isPoolable()">isPoolable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a  value indicating whether the <code>Statement</code>
 is poolable or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#isWrapperFor(java.lang.Class)">isWrapperFor</A></B>(java.lang.Class&lt;?&gt;&nbsp;iface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if this either implements the interface argument or is directly or indirectly a wrapper
 for an object that does.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setArray(int, java.sql.Array)">setArray</A></B>(int&nbsp;parameterIndex,
         java.sql.Array&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Array</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setAsciiStream(int, java.io.InputStream)">setAsciiStream</A></B>(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setAsciiStream(int, java.io.InputStream, int)">setAsciiStream</A></B>(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x,
               int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setAsciiStream(int, java.io.InputStream, long)">setAsciiStream</A></B>(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x,
               long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBigDecimal(int, java.math.BigDecimal)">setBigDecimal</A></B>(int&nbsp;parameterIndex,
              java.math.BigDecimal&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.math.BigDecimal</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBinaryStream(int, java.io.InputStream)">setBinaryStream</A></B>(int&nbsp;parameterIndex,
                java.io.InputStream&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBinaryStream(int, java.io.InputStream, int)">setBinaryStream</A></B>(int&nbsp;parameterIndex,
                java.io.InputStream&nbsp;x,
                int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBinaryStream(int, java.io.InputStream, long)">setBinaryStream</A></B>(int&nbsp;parameterIndex,
                java.io.InputStream&nbsp;x,
                long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBlob(int, java.sql.Blob)">setBlob</A></B>(int&nbsp;parameterIndex,
        java.sql.Blob&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Blob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBlob(int, java.io.InputStream)">setBlob</A></B>(int&nbsp;parameterIndex,
        java.io.InputStream&nbsp;inputStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>InputStream</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBlob(int, java.io.InputStream, long)">setBlob</A></B>(int&nbsp;parameterIndex,
        java.io.InputStream&nbsp;inputStream,
        long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>InputStream</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBoolean(int, boolean)">setBoolean</A></B>(int&nbsp;parameterIndex,
           boolean&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>boolean</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setByte(int, byte)">setByte</A></B>(int&nbsp;parameterIndex,
        byte&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>byte</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setBytes(int, byte[])">setBytes</A></B>(int&nbsp;parameterIndex,
         byte[]&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java array of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setCharacterStream(int, java.io.Reader)">setCharacterStream</A></B>(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>Reader</code>
 object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setCharacterStream(int, java.io.Reader, int)">setCharacterStream</A></B>(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;reader,
                   int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setCharacterStream(int, java.io.Reader, long)">setCharacterStream</A></B>(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;reader,
                   long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setClob(int, java.sql.Clob)">setClob</A></B>(int&nbsp;parameterIndex,
        java.sql.Clob&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Clob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setClob(int, java.io.Reader)">setClob</A></B>(int&nbsp;parameterIndex,
        java.io.Reader&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>Reader</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setClob(int, java.io.Reader, long)">setClob</A></B>(int&nbsp;parameterIndex,
        java.io.Reader&nbsp;reader,
        long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>Reader</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setCursorName(java.lang.String)">setCursorName</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the SQL cursor name to the given <code>String</code>, which
 will be used by subsequent <code>Statement</code> object
 <code>execute</code> methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setDate(int, java.sql.Date)">setDate</A></B>(int&nbsp;parameterIndex,
        java.sql.Date&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(JDBC4 clarification:)
 Sets the designated parameter to the given <code>java.sql.Date</code> value
 using the default time zone of the virtual machine that is running
 the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setDate(int, java.sql.Date, java.util.Calendar)">setDate</A></B>(int&nbsp;parameterIndex,
        java.sql.Date&nbsp;x,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Date</code> value,
 using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setDouble(int, double)">setDouble</A></B>(int&nbsp;parameterIndex,
          double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>double</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setEscapeProcessing(boolean)">setEscapeProcessing</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets escape processing on or off.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setFetchDirection(int)">setFetchDirection</A></B>(int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the driver a hint as to the direction in which
 rows will be processed in <code>ResultSet</code>
 objects created using this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setFetchSize(int)">setFetchSize</A></B>(int&nbsp;rows)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(JDBC4 clarification:)
 Gives the JDBC driver a hint as to the number of rows that should
 be fetched from the database when more rows are needed for
 <code>ResultSet</code> objects genrated by this <code>Statement</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setFloat(int, float)">setFloat</A></B>(int&nbsp;parameterIndex,
         float&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>float</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setInt(int, int)">setInt</A></B>(int&nbsp;parameterIndex,
       int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>int</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setLong(int, long)">setLong</A></B>(int&nbsp;parameterIndex,
        long&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>long</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setMaxFieldSize(int)">setMaxFieldSize</A></B>(int&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(JDBC4 clarification:) Sets the limit for the maximum number of bytes in a <code>ResultSet</code>
 Sets the limit for the maximum number of bytes that can be returned for
 character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setMaxRows(int)">setMaxRows</A></B>(int&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(JDBC4 clarification:)
 Sets the limit for the maximum number of rows that any
 <code>ResultSet</code> object  generated by this <code>Statement</code>
 object can contain to the given number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNCharacterStream(int, java.io.Reader)">setNCharacterStream</A></B>(int&nbsp;parameterIndex,
                    java.io.Reader&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>Reader</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNCharacterStream(int, java.io.Reader, long)">setNCharacterStream</A></B>(int&nbsp;parameterIndex,
                    java.io.Reader&nbsp;value,
                    long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>Reader</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNClob(int, java.sql.NClob)">setNClob</A></B>(int&nbsp;parameterIndex,
         java.sql.NClob&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>java.sql.NClob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNClob(int, java.io.Reader)">setNClob</A></B>(int&nbsp;parameterIndex,
         java.io.Reader&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>Reader</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNClob(int, java.io.Reader, long)">setNClob</A></B>(int&nbsp;parameterIndex,
         java.io.Reader&nbsp;reader,
         long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to a <code>Reader</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNString(int, java.lang.String)">setNString</A></B>(int&nbsp;parameterIndex,
           java.lang.String&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated paramter to the given <code>String</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNull(int, int)">setNull</A></B>(int&nbsp;parameterIndex,
        int&nbsp;sqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to SQL <code>NULL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setNull(int, int, java.lang.String)">setNull</A></B>(int&nbsp;parameterIndex,
        int&nbsp;sqlType,
        java.lang.String&nbsp;typeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to SQL <code>NULL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setObject(int, java.lang.Object)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setObject(int, java.lang.Object, int)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x,
          int&nbsp;targetSqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of the designated parameter with the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setObject(int, java.lang.Object, int, int)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x,
          int&nbsp;targetSqlType,
          int&nbsp;scaleOrLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of the designated parameter with the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setPoolable(boolean)">setPoolable</A></B>(boolean&nbsp;poolable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that a <code>Statement</code> be pooled or not pooled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setQueryTimeout(int)">setQueryTimeout</A></B>(int&nbsp;seconds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the number of seconds the driver will wait for a
 <code>Statement</code> object to execute to the given number of seconds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setRef(int, java.sql.Ref)">setRef</A></B>(int&nbsp;parameterIndex,
       java.sql.Ref&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given
  <code>REF(&lt;structured-type&gt;)</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setRowId(int, java.sql.RowId)">setRowId</A></B>(int&nbsp;parameterIndex,
         java.sql.RowId&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.RowId</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setShort(int, short)">setShort</A></B>(int&nbsp;parameterIndex,
         short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>short</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setSQLXML(int, java.sql.SQLXML)">setSQLXML</A></B>(int&nbsp;parameterIndex,
          java.sql.SQLXML&nbsp;xmlObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.SQLXML</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setString(int, java.lang.String)">setString</A></B>(int&nbsp;parameterIndex,
          java.lang.String&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given Java <code>String</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setTime(int, java.sql.Time)">setTime</A></B>(int&nbsp;parameterIndex,
        java.sql.Time&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Time</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setTime(int, java.sql.Time, java.util.Calendar)">setTime</A></B>(int&nbsp;parameterIndex,
        java.sql.Time&nbsp;x,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Time</code> value,
 using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setTimestamp(int, java.sql.Timestamp)">setTimestamp</A></B>(int&nbsp;parameterIndex,
             java.sql.Timestamp&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Timestamp</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)">setTimestamp</A></B>(int&nbsp;parameterIndex,
             java.sql.Timestamp&nbsp;x,
             java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.sql.Timestamp</code> value,
 using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setUnicodeStream(int, java.io.InputStream, int)">setUnicodeStream</A></B>(int&nbsp;parameterIndex,
                 java.io.InputStream&nbsp;x,
                 int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Sun does not include a reason, but presumably
      this is because setCharacterStream is now prefered</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setURL(int, java.net.URL)">setURL</A></B>(int&nbsp;parameterIndex,
       java.net.URL&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the designated parameter to the given <code>java.net.URL</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a String representation of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#unwrap(java.lang.Class)">unwrap</A></B>(java.lang.Class&lt;T&gt;&nbsp;iface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an object that implements the given interface to allow access to
 non-standard methods, or standard methods not exposed by the proxy.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="executeQuery()"><!-- --></A><H3>
executeQuery</H3>
<PRE>
public java.sql.ResultSet <B>executeQuery</B>()
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeQuery</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>ResultSet</code> object that contains the data produced by the
         query; never <code>null</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed  <code>PreparedStatement</code> or the SQL
            statement does not return a <code>ResultSet</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate()"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>()
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code> object,
 (JDBC4 clarification:)
 which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
 <code>DELETE</code>; or an SQL statement that returns nothing,
 such as a DDL statement.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(JDBC4 clarification:) either (1) the row count for SQL Data Manipulation Language (DML) statements
         or (2) 0 for SQL statements that return nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed  <code>PreparedStatement</code>
 or the SQL
            statement returns a <code>ResultSet</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="setNull(int, int)"><!-- --></A><H3>
setNull</H3>
<PRE>
public void <B>setNull</B>(int&nbsp;parameterIndex,
                    int&nbsp;sqlType)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.

 <P><B>Note:</B> You must specify the parameter's SQL type.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB currently ignores the sqlType argument.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNull</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>sqlType</CODE> - the SQL type code defined in <code>java.sql.Types</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if <code>sqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type</DL>
</DD>
</DL>
<HR>

<A NAME="setBoolean(int, boolean)"><!-- --></A><H3>
setBoolean</H3>
<PRE>
public void <B>setBoolean</B>(int&nbsp;parameterIndex,
                       boolean&nbsp;x)
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>boolean</code> value.
 The driver converts this
 (JDBC4 Modified:)
 to an SQL <code>BIT</code> or <code>BOOLEAN</code> value when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB supports BOOLEAN type for boolean values. This method can also
 be used to set the value of a parameter of the SQL type BIT(1), which is
 a bit string consisting of a 0 or 1.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBoolean</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setByte(int, byte)"><!-- --></A><H3>
setByte</H3>
<PRE>
public void <B>setByte</B>(int&nbsp;parameterIndex,
                    byte&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>byte</code> value.
 The driver converts this
 to an SQL <code>TINYINT</code> value when it sends it to the database.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setByte</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setShort(int, short)"><!-- --></A><H3>
setShort</H3>
<PRE>
public void <B>setShort</B>(int&nbsp;parameterIndex,
                     short&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>short</code> value.
 The driver converts this
 to an SQL <code>SMALLINT</code> value when it sends it to the database.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setShort</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setInt(int, int)"><!-- --></A><H3>
setInt</H3>
<PRE>
public void <B>setInt</B>(int&nbsp;parameterIndex,
                   int&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>int</code> value.
 The driver converts this
 to an SQL <code>INTEGER</code> value when it sends it to the database.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setInt</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setLong(int, long)"><!-- --></A><H3>
setLong</H3>
<PRE>
public void <B>setLong</B>(int&nbsp;parameterIndex,
                    long&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>long</code> value.
 The driver converts this
 to an SQL <code>BIGINT</code> value when it sends it to the database.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setLong</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setFloat(int, float)"><!-- --></A><H3>
setFloat</H3>
<PRE>
public void <B>setFloat</B>(int&nbsp;parameterIndex,
                     float&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>float</code> value.
 The driver converts this
 (JDBC4 correction:)
 to an SQL <code>REAL</code> value when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.1, HSQLDB handles Java positive/negative Infinity
 and NaN <code>float</code> values consistent with the Java Language
 Specification; these <em>special</em> values are now correctly stored
 to and retrieved from the database.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setFloat</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setDouble(int, double)"><!-- --></A><H3>
setDouble</H3>
<PRE>
public void <B>setDouble</B>(int&nbsp;parameterIndex,
                      double&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>double</code> value.
 The driver converts this
 to an SQL <code>DOUBLE</code> value when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.1, HSQLDB handles Java positive/negative Infinity
 and NaN <code>double</code> values consistent with the Java Language
 Specification; these <em>special</em> values are now correctly stored
 to and retrieved from the database.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setDouble</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setBigDecimal(int, java.math.BigDecimal)"><!-- --></A><H3>
setBigDecimal</H3>
<PRE>
public void <B>setBigDecimal</B>(int&nbsp;parameterIndex,
                          java.math.BigDecimal&nbsp;x)
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.math.BigDecimal</code> value.
 The driver converts this to an SQL <code>NUMERIC</code> value when
 it sends it to the database.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBigDecimal</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setString(int, java.lang.String)"><!-- --></A><H3>
setString</H3>
<PRE>
public void <B>setString</B>(int&nbsp;parameterIndex,
                      java.lang.String&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>String</code> value.
 The driver converts this
 to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
 (depending on the argument's
 size relative to the driver's limits on <code>VARCHAR</code> values)
 when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 2.0, HSQLDB represents all XXXCHAR values internally as
 java.lang.String objects; there is no appreciable difference between
 CHAR, VARCHAR and LONGVARCHAR.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setString</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setBytes(int, byte[])"><!-- --></A><H3>
setBytes</H3>
<PRE>
public void <B>setBytes</B>(int&nbsp;parameterIndex,
                     byte[]&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java array of bytes.  The driver converts
 this to an SQL <code>VARBINARY</code> or <code>LONGVARBINARY</code>
 (depending on the argument's size relative to the driver's limits on
 <code>VARBINARY</code> values) when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 2.0, HSQLDB represents all XXXBINARY values the same way
 internally; there is no appreciable difference between BINARY,
 VARBINARY and LONGVARBINARY as far as JDBC is concerned.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBytes</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setDate(int, java.sql.Date)"><!-- --></A><H3>
setDate</H3>
<PRE>
public void <B>setDate</B>(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 (JDBC4 clarification:)
 Sets the designated parameter to the given <code>java.sql.Date</code> value
 using the default time zone of the virtual machine that is running
 the application.
 The driver converts this
 to an SQL <code>DATE</code> value when it sends it to the database.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone of the
 client application is used as time zone
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setDate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setTime(int, java.sql.Time)"><!-- --></A><H3>
setTime</H3>
<PRE>
public void <B>setTime</B>(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code> value.
 The driver converts this
 to an SQL <code>TIME</code> value when it sends it to the database.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone of the
 client application is used as time zone
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTime</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setTimestamp(int, java.sql.Timestamp)"><!-- --></A><H3>
setTimestamp</H3>
<PRE>
public void <B>setTimestamp</B>(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code> value.
 The driver
 converts this to an SQL <code>TIMESTAMP</code> value when it sends it to the
 database.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone of the
 client application is used as time zone.<p>

 When this method is used to set a parameter of type TIME or
 TIME WITH TIME ZONE, then the nanosecond value of the Timestamp object
 will be used if the TIME parameter accpets fractional seconds.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTimestamp</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setAsciiStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setAsciiStream</H3>
<PRE>
public void <B>setAsciiStream</B>(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x,
                           int&nbsp;length)
                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->
 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From HSQLDB 2.0 this method uses the US-ASCII character encoding to convert bytes
 from the stream into the characters of a String.<p>
 This method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.<p>

 For long streams (larger than a few megabytes) with CLOB targets,
 it is more efficient to use a version of setCharacterStream which takes
 the a length parameter.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setAsciiStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the Java input stream that contains the ASCII parameter value<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setUnicodeStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setUnicodeStream</H3>
<PRE>
public void <B>setUnicodeStream</B>(int&nbsp;parameterIndex,
                             java.io.InputStream&nbsp;x,
                             int&nbsp;length)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Sun does not include a reason, but presumably
      this is because setCharacterStream is now prefered</I>
<P>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which
 will have the specified number of bytes.
 (JDBC4 deleted:)
 [A Unicode character has two bytes, with the first byte being the high
 byte, and the second being the low byte.] <p>

 When a very large Unicode value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from Unicode to the database char format.

 (JDBC4 added:)
 The byte format of the Unicode stream must be a Java UTF-8, as defined in the
 Java Virtual Machine Specification.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From 1.7.0 to 1.8.0.x, this method complies with behavior as defined by
 the JDBC3 specification (the stream is treated as though it has UTF16
 encoding). <p>

 Starting with 2.0, this method behaves according to the JDBC4
 specification (the stream is treated as though it has UTF-8
 encoding, as defined in the Java Virtual Machine Specification) when
 built under JDK 1.6+; otherwise, it behaves as defined by the JDBC3
 specification.  Regardless, this method is deprecated: please use
 setCharacterStream(...) instead.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setUnicodeStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>java.io.InputStream</code> object that contains the
        Unicode parameter value
 (JDBC4 deleted:)
       [as two-byte Unicode characters]<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support
 this method</DL>
</DD>
</DL>
<HR>

<A NAME="setBinaryStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setBinaryStream</H3>
<PRE>
public void <B>setBinaryStream</B>(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x,
                            int&nbsp;length)
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this method works according to the standard.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBinaryStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the java input stream which contains the binary parameter value<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="clearParameters()"><!-- --></A><H3>
clearParameters</H3>
<PRE>
public void <B>clearParameters</B>()
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Clears the current parameter values immediately.
 <P>In general, parameter values remain in force for repeated use of a
 statement. Setting a parameter value automatically clears its
 previous value.  However, in some cases it is useful to immediately
 release the resources used by the current parameter values; this can
 be done by calling the method <code>clearParameters</code>.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>clearParameters</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object, int, int)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType,
                      int&nbsp;scaleOrLength)
               throws java.sql.SQLException</PRE>
<DL>
<DD><p>Sets the value of the designated parameter with the given object. The second
 argument must be an object type; for integral values, the
 <code>java.lang</code> equivalent objects should be used.

 If the second argument is an <code>InputStream</code> then the stream must contain
 the number of bytes specified by scaleOrLength.  If the second argument is a
 <code>Reader</code> then the reader must contain the number of characters specified
 by scaleOrLength. If these conditions are not true the driver will generate a
 <code>SQLException</code> when the prepared statement is executed.

 <p>The given Java object will be converted to the given targetSqlType
 before being sent to the database.

 If the object has a custom mapping (is of a class implementing the
 interface <code>SQLData</code>),
 the JDBC driver should call the method <code>SQLData.writeSQL</code> to
 write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
  <code>Struct</code>, <code>java.net.URL</code>,
 or <code>Array</code>, the driver should pass it to the database as a
 value of the corresponding SQL type.

 <p>Note that this method may be used to pass database-specific
 abstract data types.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DD><CODE>targetSqlType</CODE> - the SQL type (as defined in java.sql.Types) to be
 sent to the database. The scale argument may further qualify this type.<DD><CODE>scaleOrLength</CODE> - for <code>java.sql.Types.DECIMAL</code>
          or <code>java.sql.Types.NUMERIC types</code>,
          this is the number of digits after the decimal point. For
          Java Object types <code>InputStream</code> and <code>Reader</code>,
          this is the length
          of the data in the stream or reader.  For all other types,
          this value will be ignored.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>PreparedStatement</code> or
            if the Java Object specified by x is an InputStream
            or Reader object and the value of the scale parameter is less
            than zero
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if <code>targetSqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type<DT><B>See Also:</B><DD><CODE>Types</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object, int)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter with the given object.
 This method is like the method <code>setObject</code>
 above, except that it assumes a scale of zero.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this method supports conversions listed in the
 conversion table B-5 of the JDBC 3 specification.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DD><CODE>targetSqlType</CODE> - the SQL type (as defined in java.sql.Types) to be
                      sent to the database
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if <code>targetSqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setObject(int, java.lang.Object)"><CODE>setObject(int,Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 <p>Sets the value of the designated parameter using the given object.
 The second parameter must be of type <code>Object</code>; therefore, the
 <code>java.lang</code> equivalent objects should be used for built-in types.

 <p>The JDBC specification specifies a standard mapping from
 Java <code>Object</code> types to SQL types.  The given argument
 will be converted to the corresponding SQL type before being
 sent to the database.

 <p>Note that this method may be used to pass datatabase-
 specific abstract data types, by using a driver-specific Java
 type.

 If the object is of a class implementing the interface <code>SQLData</code>,
 the JDBC driver should call the method <code>SQLData.writeSQL</code>
 to write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>, (JDBC4 new:) [ <code>NClob</code> ],
  <code>Struct</code>, <code>java.net.URL</code>, (JDBC4 new:) [ <code>RowId</code>, <code>SQLXML</code> ]
 or <code>Array</code>, the driver should pass it to the database as a
 value of the corresponding SQL type.
 <P>
 <b>Note:</b> Not all databases allow for a non-typed Null to be sent to
 the backend. For maximum portability, the <code>setNull</code> or the
 <code>setObject(int parameterIndex, Object x, int sqlType)</code>
 method should be used
 instead of <code>setObject(int parameterIndex, Object x)</code>.
 <p>
 <b>Note:</b> This method throws an exception if there is an ambiguity, for example, if the
 object is of a class implementing more than one of the interfaces named above.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3><p>

 Since 1.7.2, this method supports conversions listed in the conversion
 table B-5 of the JDBC 3 specification.
 </div>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
  this method is called on a closed <code>PreparedStatement</code>
 or the type of the given object is ambiguous</DL>
</DD>
</DL>
<HR>

<A NAME="execute()"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>()
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code> object,
 which may be any kind of SQL statement.
 Some prepared statements return multiple results; the <code>execute</code>
 method handles these complex statements as well as the simpler
 form of statements handled by the methods <code>executeQuery</code>
 and <code>executeUpdate</code>.
 <P>
 The <code>execute</code> method returns a <code>boolean</code> to
 indicate the form of the first result.  You must call either the method
 <code>getResultSet</code> or <code>getUpdateCount</code>
 to retrieve the result; you must call <code>getMoreResults</code> to
 move to any subsequent result(s).
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 If the statatement is a call to a PROCEDURE, it may return multiple
 multiple fetchable results. <p>

 </div>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the first result is a <code>ResultSet</code>
         object; <code>false</code> if the first result is an update
         count or there is no result
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>PreparedStatement</code>
 or an argument is supplied to this method<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCStatement.html#execute(java.lang.String)"><CODE>JDBCStatement.execute(java.lang.String)</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/JDBCStatement.html#getResultSet()"><CODE>JDBCStatement.getResultSet()</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/JDBCStatement.html#getUpdateCount()"><CODE>JDBCStatement.getUpdateCount()</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/JDBCStatement.html#getMoreResults()"><CODE>JDBCStatement.getMoreResults()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addBatch()"><!-- --></A><H3>
addBatch</H3>
<PRE>
public void <B>addBatch</B>()
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>addBatch</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
 JDBCParameterMetaData)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCStatement.html#addBatch(java.lang.String)"><CODE>JDBCStatement.addBatch(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCharacterStream(int, java.io.Reader, int)"><!-- --></A><H3>
setCharacterStream</H3>
<PRE>
public void <B>setCharacterStream</B>(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader,
                               int&nbsp;length)
                        throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From HSQLDB 2.0 this method uses streaming to send data
 when the target is a CLOB.<p>
 HSQLDB represents CHARACTER and related SQL types as UTF16 Unicode
 internally, so this method does not perform any conversion.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - the <code>java.io.Reader</code> object that contains the
        Unicode data<DD><CODE>length</CODE> - the number of characters in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
 JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRef(int, java.sql.Ref)"><!-- --></A><H3>
setRef</H3>
<PRE>
public void <B>setRef</B>(int&nbsp;parameterIndex,
                   java.sql.Ref&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
  <code>REF(&lt;structured-type&gt;)</code> value.
 The driver converts this to an SQL <code>REF</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 2.0 HSQLDB does not support the SQL REF type. Calling this method
 throws an exception.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setRef</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - an SQL <code>REF</code> value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
 JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBlob(int, java.sql.Blob)"><!-- --></A><H3>
setBlob</H3>
<PRE>
public void <B>setBlob</B>(int&nbsp;parameterIndex,
                    java.sql.Blob&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Blob</code> object.
 The driver converts this to an SQL <code>BLOB</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 For parameters of type Blob, setBlob works normally.<p>

 In addition since 1.7.2, setBlob is supported for BINARY and VARBINARY
 parameters. In this context, the Blob object is
 hard-limited to those of length less than or equal to Integer.MAX_VALUE.
 In practice, soft limits such as available heap and maximum disk usage
 per file (such as the transaction log) dictate a much smaller maximum
 length. <p>

 For BINARY and VARBINARY parameter types setBlob(i,x) is roughly
 equivalent (null and length handling not shown) to:<p>

 <pre class="JavaCodeExample">
 <b>setBinaryStream</b>(i, x.<b>getBinaryStream</b>(), (<span class="JavaKeyWord">int</span>) x.<b>length</b>());
 </pre></div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBlob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>Blob</code> object that maps an SQL <code>BLOB</code> value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
 JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClob(int, java.sql.Clob)"><!-- --></A><H3>
setClob</H3>
<PRE>
public void <B>setClob</B>(int&nbsp;parameterIndex,
                    java.sql.Clob&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Clob</code> object.
 The driver converts this to an SQL <code>CLOB</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 For parameters of type Clob, setClob works normally.<p>

 In addition since 1.7.2, setClob is supported for CHARACTER and VARCHAR
 parameters. In this context, the Clob object is
 hard-limited to those of length less than or equal to Integer.MAX_VALUE.
 In practice, soft limits such as available heap and maximum disk usage
 per file (such as the transaction log) dictate a much smaller maximum
 length. <p>

 For CHARACTER and VARCHAR parameter types setClob(i,x) is roughly
 equivalent (null and length handling not shown) to:<p>

 <pre class="JavaCodeExample">
 <b>setCharacterStream</b>(i, x.<b>getCharacterStream</b>(), (<span class="JavaKeyWord">int</span>) x.<b>length</b>());
 </pre></div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>Clob</code> object that maps an SQL <code>CLOB</code> value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
  JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setArray(int, java.sql.Array)"><!-- --></A><H3>
setArray</H3>
<PRE>
public void <B>setArray</B>(int&nbsp;parameterIndex,
                     java.sql.Array&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Array</code> object.
 The driver converts this to an SQL <code>ARRAY</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From version 2.0, HSQLDB supports the SQL ARRAY type.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setArray</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
   JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMetaData()"><!-- --></A><H3>
getMetaData</H3>
<PRE>
public java.sql.ResultSetMetaData <B>getMetaData</B>()
                                       throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.
 <P>
 Because a <code>PreparedStatement</code> object is precompiled, it is
 possible to know about the <code>ResultSet</code> object that it will
 return without having to execute it.  Consequently, it is possible
 to invoke the method <code>getMetaData</code> on a
 <code>PreparedStatement</code> object rather than waiting to execute
 it and then invoking the <code>ResultSet.getMetaData</code> method
 on the <code>ResultSet</code> object that is returned.
 <P>
 <B>NOTE:</B> Using this method may be expensive for some drivers due
 to the lack of underlying DBMS support.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this feature is supported and is <em>inexpensive</em> as
 it is backed by underlying DBMS support.  If the statement
 generates an update count, then null is returned.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMetaData</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the description of a <code>ResultSet</code> object's columns or
         <code>null</code> if the driver cannot return a
         <code>ResultSetMetaData</code> object
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support
 this method<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
   JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDate(int, java.sql.Date, java.util.Calendar)"><!-- --></A><H3>
setDate</H3>
<PRE>
public void <B>setDate</B>(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Date</code> value,
 using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>DATE</code> value,
 which the driver then sends to the database.  With
 a <code>Calendar</code> object, the driver can calculate the date
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setDate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
            to construct the date
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
   JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTime(int, java.sql.Time, java.util.Calendar)"><!-- --></A><H3>
setTime</H3>
<PRE>
public void <B>setTime</B>(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code> value,
 using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIME</code> value,
 which the driver then sends to the database.  With
 a <code>Calendar</code> object, the driver can calculate the time
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone (including
 Daylight Saving Time) of the Calendar is used as time zone for the
 value.<p>

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTime</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
            to construct the time
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
   JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTimestamp(int, java.sql.Timestamp, java.util.Calendar)"><!-- --></A><H3>
setTimestamp</H3>
<PRE>
public void <B>setTimestamp</B>(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x,
                         java.util.Calendar&nbsp;cal)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code> value,
 using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIMESTAMP</code> value,
 which the driver then sends to the database.  With a
  <code>Calendar</code> object, the driver can calculate the timestamp
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone (including
 Daylight Saving Time) of the Calendar is used as time zone.<p>
 In this case, if the Calendar argument is null, then the default Calendar
 for the clients JVM is used as the Calendar<p>

 When this method is used to set a parameter of type TIME or
 TIME WITH TIME ZONE, then the nanosecond value of the Timestamp object
 is used if the TIME parameter accepts fractional seconds.<p>

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTimestamp</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
            to construct the timestamp
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
   JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNull(int, int, java.lang.String)"><!-- --></A><H3>
setNull</H3>
<PRE>
public void <B>setNull</B>(int&nbsp;parameterIndex,
                    int&nbsp;sqlType,
                    java.lang.String&nbsp;typeName)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.
 This version of the method <code>setNull</code> should
 be used for user-defined types and REF type parameters.  Examples
 of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
 named array types.

 <P><B>Note:</B> To be portable, applications must give the
 SQL type code and the fully-qualified SQL type name when specifying
 a NULL user-defined or REF parameter.  In the case of a user-defined type
 the name is the type name of the parameter itself.  For a REF
 parameter, the name is the type name of the referenced type.  If
 a JDBC driver does not need the type code or type name information,
 it may ignore it.

 Although it is intended for user-defined and Ref parameters,
 this method may be used to set a null parameter of any JDBC type.
 If the parameter does not have a user-defined or REF type, the given
 typeName is ignored.

 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB simply ignores the sqlType and typeName arguments.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNull</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>sqlType</CODE> - a value from <code>java.sql.Types</code><DD><CODE>typeName</CODE> - the fully-qualified name of an SQL user-defined type;
  ignored if the parameter is not a user-defined type or REF
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if <code>sqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type or if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview for
   JDBCParameterMetaData)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="executeBatch()"><!-- --></A><H3>
executeBatch</H3>
<PRE>
public int[] <B>executeBatch</B>()
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.
 The <code>int</code> elements of the array that is returned are ordered
 to correspond to the commands in the batch, which are ordered
 according to the order in which they were added to the batch.
 The elements in the array returned by the method <code>executeBatch</code>
 may be one of the following:
 <OL>
 <LI>A number greater than or equal to zero -- indicates that the
 command was processed successfully and is an update count giving the
 number of rows in the database that were affected by the command's
 execution
 <LI>A value of <code>SUCCESS_NO_INFO</code> -- indicates that the command was
 processed successfully but that the number of rows affected is
 unknown
 <P>
 If one of the commands in a batch update fails to execute properly,
 this method throws a <code>BatchUpdateException</code>, and a JDBC
 driver may or may not continue to process the remaining commands in
 the batch.  However, the driver's behavior must be consistent with a
 particular DBMS, either always continuing to process commands or never
 continuing to process commands.  If the driver continues processing
 after a failure, the array returned by the method
 <code>BatchUpdateException.getUpdateCounts</code>
 will contain as many elements as there are commands in the batch, and
 at least one of the elements will be the following:
 <P>
 <LI>A value of <code>EXECUTE_FAILED</code> -- indicates that the command failed
 to execute successfully and occurs only if a driver continues to
 process commands after a command fails
 </OL>
 <P>
 A driver is not required to implement this method.
 The possible implementations and return values have been modified in
 the Java 2 SDK, Standard Edition, version 1.3 to
 accommodate the option of continuing to proccess commands in a batch
 update after a <code>BatchUpdateException</code> obejct has been thrown. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Starting with HSQLDB 1.7.2, this feature is supported. <p>

 HSQLDB stops execution of commands in a batch when one of the commands
 results in an exception. The size of the returned array equals the
 number of commands that were executed successfully.<p>

 When the product is built under the JAVA1 target, an exception
 is never thrown and it is the responsibility of the client software to
 check the size of the  returned update count array to determine if any
 batch items failed.  To build and run under the JAVA2 target, JDK/JRE
 1.3 or higher must be used.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeBatch</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array of update counts containing one element for each
 command in the batch.  The elements of the array are ordered according
 to the order in which commands were added to the batch.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the
 driver does not support batch statements. Throws <CODE>BatchUpdateException</CODE>
 (a subclass of <code>SQLException</code>) if one of the commands sent to the
 database fails to execute properly or attempts to return a result set.<DT><B>Since:</B></DT>
  <DD>JDK 1.3 (JDK 1.1.x developers: read the overview for
 JDBCStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#addBatch()"><CODE>addBatch()</CODE></A>, 
<CODE>DatabaseMetaData.supportsBatchUpdates()</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setEscapeProcessing(boolean)"><!-- --></A><H3>
setEscapeProcessing</H3>
<PRE>
public void <B>setEscapeProcessing</B>(boolean&nbsp;enable)
                         throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets escape processing on or off. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 As per JDBC spec, calling this method has no effect.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setEscapeProcessing</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <code>true</code> to enable escape processing;
     <code>false</code> to disable it
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="addBatch(java.lang.String)"><!-- --></A><H3>
addBatch</H3>
<PRE>
public void <B>addBatch</B>(java.lang.String&nbsp;sql)
              throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>addBatch</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="executeQuery(java.lang.String)"><!-- --></A><H3>
executeQuery</H3>
<PRE>
public java.sql.ResultSet <B>executeQuery</B>(java.lang.String&nbsp;sql)
                                throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeQuery</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Returns:</B><DD>nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.lang.String)"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>(java.lang.String&nbsp;sql)
                throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Returns:</B><DD>nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate(java.lang.String)"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>(java.lang.String&nbsp;sql)
                  throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Returns:</B><DD>nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws java.sql.SQLException</PRE>
<DL>
<DD>Does the specialized work required to free this object's resources and
 that of it's parent class. <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>close</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Retrieves a String representation of this object.  <p>

 The representation is of the form: <p>

 class-name@hash[sql=[char-sequence], parameters=[p1, ...pi, ...pn]] <p>

 p1, ...pi, ...pn are the String representations of the currently set
 parameter values that will be used with the non-batch execution
 methods. <p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a String representation of this object</DL>
</DD>
</DL>
<HR>

<A NAME="setURL(int, java.net.URL)"><!-- --></A><H3>
setURL</H3>
<PRE>
public void <B>setURL</B>(int&nbsp;parameterIndex,
                   java.net.URL&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.net.URL</code> value.
 The driver converts this to an SQL <code>DATALINK</code> value
 when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 2.0, HSQLDB does not support the DATALINK SQL type for which this
 method is intended. Calling this method throws an exception.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setURL</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the <code>java.net.URL</code> object to be set
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQL 1.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getParameterMetaData()"><!-- --></A><H3>
getParameterMetaData</H3>
<PRE>
public java.sql.ParameterMetaData <B>getParameterMetaData</B>()
                                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the number, types and properties of this
 <code>PreparedStatement</code> object's parameters.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getParameterMetaData</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>ParameterMetaData</code> object that contains information
         about the number, types and properties for each
  parameter marker of this <code>PreparedStatement</code> object
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQL 1.7.0</DD>
<DT><B>See Also:</B><DD><CODE>ParameterMetaData</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate(java.lang.String, int)"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>(java.lang.String&nbsp;sql,
                         int&nbsp;autoGeneratedKeys)
                  throws java.sql.SQLException</PRE>
<DL>
<DD>Statement methods that must be overridden in this class and throw
 an exception.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.lang.String, int)"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>(java.lang.String&nbsp;sql,
                       int&nbsp;autoGeneratedKeys)
                throws java.sql.SQLException</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate(java.lang.String, int[])"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>(java.lang.String&nbsp;sql,
                         int[]&nbsp;columnIndexes)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.lang.String, int[])"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>(java.lang.String&nbsp;sql,
                       int[]&nbsp;columnIndexes)
                throws java.sql.SQLException</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate(java.lang.String, java.lang.String[])"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>(java.lang.String&nbsp;sql,
                         java.lang.String[]&nbsp;columnNames)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.lang.String, java.lang.String[])"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>(java.lang.String&nbsp;sql,
                       java.lang.String[]&nbsp;columnNames)
                throws java.sql.SQLException</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getMoreResults(int)"><!-- --></A><H3>
getMoreResults</H3>
<PRE>
public boolean <B>getMoreResults</B>(int&nbsp;current)
                       throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Moves to this <code>Statement</code> object's next result, deals with
 any current <code>ResultSet</code> object(s) according  to the instructions
 specified by the given flag, and returns
 <code>true</code> if the next result is a <code>ResultSet</code> object.

 <P>There are no more results when the following is true:
 <PRE>
     // stmt is a Statement object
     ((stmt.getMoreResults(current) == false) && (stmt.getUpdateCount() == -1))
 </PRE>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB supports this feature. <p>

 This is used with CallableStatement objects that return multiple
 ResultSet objects.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMoreResults</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - one of the following <code>Statement</code>
        constants indicating what should happen to current
        <code>ResultSet</code> objects obtained using the method
        <code>getResultSet</code>:
        <code>Statement.CLOSE_CURRENT_RESULT</code>,
        <code>Statement.KEEP_CURRENT_RESULT</code>, or
        <code>Statement.CLOSE_ALL_RESULTS</code>
<DT><B>Returns:</B><DD><code>true</code> if the next result is a <code>ResultSet</code>
         object; <code>false</code> if it is an update count or there are no
         more results
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the argument
             supplied is not one of the following:
        <code>Statement.CLOSE_CURRENT_RESULT</code>,
        <code>Statement.KEEP_CURRENT_RESULT</code>, or
        <code>Statement.CLOSE_ALL_RESULTS</code><DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQLDB 1.7</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute()"><CODE>execute()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGeneratedKeys()"><!-- --></A><H3>
getGeneratedKeys</H3>
<PRE>
public java.sql.ResultSet <B>getGeneratedKeys</B>()
                                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves any auto-generated keys created as a result of executing this
 <code>Statement</code> object. If this <code>Statement</code> object did
 not generate any keys, an empty <code>ResultSet</code>
 object is returned.
 <p>(JDBC4 clarification:)
 <p><B>Note:</B>If the columns which represent the auto-generated keys were not specified,
 the JDBC driver implementation will determine the columns which best represent the auto-generated keys.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Starting with version 2.0, HSQLDB supports this feature with single-row and
 multi-row insert, update and merge statements. <p>

 This method returns a result set only if
 the executeUpdate methods that was used is one of the three methods that
 have the extra parameter indicating return of generated keys<p>

 If the executeUpaged method did not specify the columns which represent
 the auto-generated keys the IDENTITY column or GENERATED column(s) of the
 table are returned.<p>

 The executeUpdate methods with column indexes or column names return the
 post-insert or post-update values of the specified columns, whether the
 columns are generated or not. This allows values that have been modified
 by execution of triggers to be returned.<p>

 If column names or indexes provided by the user in the executeUpdate()
 method calls do not correspond to table columns (incorrect names or
 indexes larger than the coloum count), an empty result is returned.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getGeneratedKeys</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>ResultSet</code> object containing the auto-generated key(s)
         generated by the execution of this <code>Statement</code> object
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQLDB 1.7</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResultSetHoldability()"><!-- --></A><H3>
getResultSetHoldability</H3>
<PRE>
public int <B>getResultSetHoldability</B>()
                            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the result set holdability for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Starting with 1.7.2, this method returns HOLD_CURSORS_OVER_COMMIT
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getResultSetHoldability</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQLDB 1.7</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isClosed()"><!-- --></A><H3>
isClosed</H3>
<PRE>
public boolean <B>isClosed</B>()</PRE>
<DL>
<DD>Retrieves whether this <code>Statement</code> object has been closed. A <code>Statement</code> is closed if the
 method close has been called on it, or if it is automatically closed.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>isClosed</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if this <code>Statement</code> object is closed; false if it is still open
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRowId(int, java.sql.RowId)"><!-- --></A><H3>
setRowId</H3>
<PRE>
public void <B>setRowId</B>(int&nbsp;parameterIndex,
                     java.sql.RowId&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given <code>java.sql.RowId</code> object. The
 driver converts this to a SQL <code>ROWID</code> value when it sends it
 to the database
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setRowId</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNString(int, java.lang.String)"><!-- --></A><H3>
setNString</H3>
<PRE>
public void <B>setNString</B>(int&nbsp;parameterIndex,
                       java.lang.String&nbsp;value)
                throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated paramter to the given <code>String</code> object.
 The driver converts this to a SQL <code>NCHAR</code> or
 <code>NVARCHAR</code> or <code>LONGNVARCHAR</code> value
 (depending on the argument's
 size relative to the driver's limits on <code>NVARCHAR</code> values)
 when it sends it to the database.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNString</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - of the first parameter is 1, the second is 2, ...<DD><CODE>value</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if the driver does not support national
         character sets;  if the driver can detect that a data conversion
  error could occur ; if a database access error occurs; or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNCharacterStream(int, java.io.Reader, long)"><!-- --></A><H3>
setNCharacterStream</H3>
<PRE>
public void <B>setNCharacterStream</B>(int&nbsp;parameterIndex,
                                java.io.Reader&nbsp;value,
                                long&nbsp;length)
                         throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>Reader</code> object. The
 <code>Reader</code> reads the data till end-of-file is reached. The
 driver does the necessary conversion from Java character format to
 the national character set in the database.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - of the first parameter is 1, the second is 2, ...<DD><CODE>value</CODE> - the parameter value<DD><CODE>length</CODE> - the number of characters in the parameter data.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if the driver does not support national
         character sets;  if the driver can detect that a data conversion
  error could occur ; if a database access error occurs; or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNClob(int, java.sql.NClob)"><!-- --></A><H3>
setNClob</H3>
<PRE>
public void <B>setNClob</B>(int&nbsp;parameterIndex,
                     java.sql.NClob&nbsp;value)
              throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>java.sql.NClob</code> object. The driver converts this to a
 SQL <code>NCLOB</code> value when it sends it to the database.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - of the first parameter is 1, the second is 2, ...<DD><CODE>value</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if the driver does not support national
         character sets;  if the driver can detect that a data conversion
  error could occur ; if a database access error occurs; or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClob(int, java.io.Reader, long)"><!-- --></A><H3>
setClob</H3>
<PRE>
public void <B>setClob</B>(int&nbsp;parameterIndex,
                    java.io.Reader&nbsp;reader,
                    long&nbsp;length)
             throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number
 of characters specified by length otherwise a <code>SQLException</code> will be
 generated when the <code>PreparedStatement</code> is executed.
 This method differs from the <code>setCharacterStream (int, Reader, int)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be send to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - An object that contains the data to set the parameter value to.<DD><CODE>length</CODE> - the number of characters in the parameter data.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs, this method is called on
 a closed <code>PreparedStatement</code>, if parameterIndex does not correspond to a parameter
 marker in the SQL statement, or if the length specified is less than zero.
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBlob(int, java.io.InputStream, long)"><!-- --></A><H3>
setBlob</H3>
<PRE>
public void <B>setBlob</B>(int&nbsp;parameterIndex,
                    java.io.InputStream&nbsp;inputStream,
                    long&nbsp;length)
             throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>InputStream</code> object.  The inputstream must contain  the number
 of characters specified by length otherwise a <code>SQLException</code> will be
 generated when the <code>PreparedStatement</code> is executed.
 This method differs from the <code>setBinaryStream (int, InputStream, int)</code>
 method because it informs the driver that the parameter value should be
 sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used,
 the driver may have to do extra work to determine whether the parameter
 data should be send to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 In HSQLDB 2.0, this method uses streaming to send the data when the
 stream is assigned to a BLOB target. For other binary targets the
 stream is read on the client side and a byte array is sent.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBlob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1,
 the second is 2, ...<DD><CODE>inputStream</CODE> - An object that contains the data to set the parameter
 value to.<DD><CODE>length</CODE> - the number of bytes in the parameter data.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>PreparedStatement</code>,
 if parameterIndex does not correspond
 to a parameter marker in the SQL statement,  if the length specified
 is less than zero or if the number of bytes in the inputstream does not match
 the specfied length.
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNClob(int, java.io.Reader, long)"><!-- --></A><H3>
setNClob</H3>
<PRE>
public void <B>setNClob</B>(int&nbsp;parameterIndex,
                     java.io.Reader&nbsp;reader,
                     long&nbsp;length)
              throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number
 of characters specified by length otherwise a <code>SQLException</code> will be
 generated when the <code>PreparedStatement</code> is executed.
 This method differs from the <code>setCharacterStream (int, Reader, int)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be send to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - An object that contains the data to set the parameter value to.<DD><CODE>length</CODE> - the number of characters in the parameter data.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if the length specified is less than zero;
 if the driver does not support national character sets;
 if the driver can detect that a data conversion
  error could occur;  if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSQLXML(int, java.sql.SQLXML)"><!-- --></A><H3>
setSQLXML</H3>
<PRE>
public void <B>setSQLXML</B>(int&nbsp;parameterIndex,
                      java.sql.SQLXML&nbsp;xmlObject)
               throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given <code>java.sql.SQLXML</code> object.
 The driver converts this to an
 SQL <code>XML</code> value when it sends it to the database.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setSQLXML</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1, the second is 2, ...<DD><CODE>xmlObject</CODE> - a <code>SQLXML</code> object that maps an SQL <code>XML</code> value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
  this method is called on a closed <code>PreparedStatement</code>
 or the <code>java.xml.transform.Result</code>,
  <code>Writer</code> or <code>OutputStream</code> has not been closed for
 the <code>SQLXML</code> object
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAsciiStream(int, java.io.InputStream, long)"><!-- --></A><H3>
setAsciiStream</H3>
<PRE>
public void <B>setAsciiStream</B>(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x,
                           long&nbsp;length)
                    throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From HSQLDB 2.0 this method uses the US-ASCII character encoding to convert bytes
 from the stream into the characters of a String.<p>
 This method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.<p>

 For long streams (larger than a few megabytes) with CLOB targets,
 it is more efficient to use a version of setCharacterStream which takes
 the a length parameter.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setAsciiStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the Java input stream that contains the ASCII parameter value<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.6 b86, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBinaryStream(int, java.io.InputStream, long)"><!-- --></A><H3>
setBinaryStream</H3>
<PRE>
public void <B>setBinaryStream</B>(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x,
                            long&nbsp;length)
                     throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 This method uses streaming to send the data when the
 stream is assigned to a BLOB target. For other binary targets the
 stream is read on the client side and a byte array is sent.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBinaryStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the java input stream which contains the binary parameter value<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.6 b86, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCharacterStream(int, java.io.Reader, long)"><!-- --></A><H3>
setCharacterStream</H3>
<PRE>
public void <B>setCharacterStream</B>(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader,
                               long&nbsp;length)
                        throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 This method uses streaming to send data
 when the target is a CLOB.<p>
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - the <code>java.io.Reader</code> object that contains the
        Unicode data<DD><CODE>length</CODE> - the number of characters in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.6 b86, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAsciiStream(int, java.io.InputStream)"><!-- --></A><H3>
setAsciiStream</H3>
<PRE>
public void <B>setAsciiStream</B>(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x)
                    throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given input stream.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setAsciiStream</code> which takes a length parameter.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 In HSQLDB 2.0, this method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.

 For long streams (larger than a few megabytes), it is more efficient to
 use a version of setCharacterStream which takes the a length parameter.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setAsciiStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the Java input stream that contains the ASCII parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBinaryStream(int, java.io.InputStream)"><!-- --></A><H3>
setBinaryStream</H3>
<PRE>
public void <B>setBinaryStream</B>(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x)
                     throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given input stream.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setBinaryStream</code> which takes a length parameter.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 This method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.<p>

 For long streams (larger than a few megabytes) with CLOB targets,
 it is more efficient to use a version of setCharacterStream which takes
 the a length parameter.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBinaryStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the java input stream which contains the binary parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCharacterStream(int, java.io.Reader)"><!-- --></A><H3>
setCharacterStream</H3>
<PRE>
public void <B>setCharacterStream</B>(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader)
                        throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to the given <code>Reader</code>
 object.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setCharacterStream</code> which takes a length parameter.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 In HSQLDB 2.0, this method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.

 For long streams (larger than a few megabytes), it is more efficient to
 use a version of setCharacterStream which takes the a length parameter.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - the <code>java.io.Reader</code> object that contains the
        Unicode data
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNCharacterStream(int, java.io.Reader)"><!-- --></A><H3>
setNCharacterStream</H3>
<PRE>
public void <B>setNCharacterStream</B>(int&nbsp;parameterIndex,
                                java.io.Reader&nbsp;value)
                         throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>Reader</code> object. The
   <code>Reader</code> reads the data till end-of-file is reached. The
   driver does the necessary conversion from Java character format to
   the national character set in the database.

   <P><B>Note:</B> This stream object can either be a standard
   Java stream object or your own subclass that implements the
   standard interface.
   <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   it might be more efficient to use a version of
   <code>setNCharacterStream</code> which takes a length parameter.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - of the first parameter is 1, the second is 2, ...<DD><CODE>value</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
   marker in the SQL statement; if the driver does not support national
           character sets;  if the driver can detect that a data conversion
    error could occur; if a database access error occurs; or
   this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClob(int, java.io.Reader)"><!-- --></A><H3>
setClob</H3>
<PRE>
public void <B>setClob</B>(int&nbsp;parameterIndex,
                    java.io.Reader&nbsp;reader)
             throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>Reader</code> object.
 This method differs from the <code>setCharacterStream (int, Reader)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be sent to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>

 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setClob</code> which takes a length parameter.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - An object that contains the data to set the parameter value to.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs; this method is called on
 a closed <code>PreparedStatement</code>or if parameterIndex does not correspond to a parameter
 marker in the SQL statement
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBlob(int, java.io.InputStream)"><!-- --></A><H3>
setBlob</H3>
<PRE>
public void <B>setBlob</B>(int&nbsp;parameterIndex,
                    java.io.InputStream&nbsp;inputStream)
             throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>InputStream</code> object.
 This method differs from the <code>setBinaryStream (int, InputStream)</code>
 method because it informs the driver that the parameter value should be
 sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used,
 the driver may have to do extra work to determine whether the parameter
 data should be sent to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>

 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setBlob</code> which takes a length parameter.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBlob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1,
 the second is 2, ...<DD><CODE>inputStream</CODE> - An object that contains the data to set the parameter
 value to.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs;
 this method is called on a closed <code>PreparedStatement</code> or
 if parameterIndex does not correspond
 to a parameter marker in the SQL statement,
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNClob(int, java.io.Reader)"><!-- --></A><H3>
setNClob</H3>
<PRE>
public void <B>setNClob</B>(int&nbsp;parameterIndex,
                     java.io.Reader&nbsp;reader)
              throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the designated parameter to a <code>Reader</code> object.
 This method differs from the <code>setCharacterStream (int, Reader)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be sent to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code>
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setNClob</code> which takes a length parameter.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - index of the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - An object that contains the data to set the parameter value to.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement;
 if the driver does not support national character sets;
 if the driver can detect that a data conversion
  error could occur;  if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method<DT><B>Since:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxFieldSize()"><!-- --></A><H3>
getMaxFieldSize</H3>
<PRE>
public int <B>getMaxFieldSize</B>()
                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the maximum number of bytes that can be
 returned for character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.
 This limit applies only to  <code>BINARY</code>, <code>VARBINARY</code>,
 <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,
 (JDBC4 new:) <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>
 and <code>LONGVARCHAR</code> columns.  If the limit is exceeded, the
 excess data is silently discarded.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB always returns zero, meaning there is no limit.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMaxFieldSize</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current column size limit for columns storing character and
         binary values; zero means there is no limit
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setMaxFieldSize(int)"><CODE>setMaxFieldSize(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMaxFieldSize(int)"><!-- --></A><H3>
setMaxFieldSize</H3>
<PRE>
public void <B>setMaxFieldSize</B>(int&nbsp;max)
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 (JDBC4 clarification:) Sets the limit for the maximum number of bytes in a <code>ResultSet</code>
 Sets the limit for the maximum number of bytes that can be returned for
 character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.

 This limit applies
 only to <code>BINARY</code>, <code>VARBINARY</code>,
 <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,
 (JDBC4 new:) <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code> and
 <code>LONGVARCHAR</code> fields.  If the limit is exceeded, the excess data
 is silently discarded. For maximum portability, use values
 greater than 256.
 <!-- emd generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 To present, calls to this method are simply ignored; HSQLDB always
 stores the full number of bytes when dealing with any of the field types
 mentioned above. These types all have an absolute maximum element upper
 bound determined by the Java array index limit
 java.lang.Integer.MAX_VALUE.  For XXXBINARY types, this translates to
 Integer.MAX_VALUE bytes.  For XXXCHAR types, this translates to
 2 * Integer.MAX_VALUE bytes (2 bytes / character). <p>

 In practice, field sizes are limited to values much smaller than the
 absolute maximum element upper bound, in particular due to limits imposed
 on the maximum available Java heap memory.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setMaxFieldSize</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>max</CODE> - the new column size limit in bytes; zero means there is no limit
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition max >= 0 is not satisfied<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMaxFieldSize()"><CODE>getMaxFieldSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMaxRows()"><!-- --></A><H3>
getMaxRows</H3>
<PRE>
public int <B>getMaxRows</B>()
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the maximum number of rows that a
 <code>ResultSet</code> object produced by this
 <code>Statement</code> object can contain.  If this limit is exceeded,
 the excess rows are silently dropped.
 <!-- start generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMaxRows</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current maximum number of rows for a <code>ResultSet</code>
         object produced by this <code>Statement</code> object;
         zero means there is no limit
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setMaxRows(int)"><CODE>setMaxRows(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMaxRows(int)"><!-- --></A><H3>
setMaxRows</H3>
<PRE>
public void <B>setMaxRows</B>(int&nbsp;max)
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 (JDBC4 clarification:)
 Sets the limit for the maximum number of rows that any
 <code>ResultSet</code> object  generated by this <code>Statement</code>
 object can contain to the given number.
 If the limit is exceeded, the excess
 rows are silently dropped.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setMaxRows</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>max</CODE> - the new max rows limit; zero means there is no limit
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition max >= 0 is not satisfied<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getMaxRows()"><CODE>getMaxRows()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getQueryTimeout()"><!-- --></A><H3>
getQueryTimeout</H3>
<PRE>
public int <B>getQueryTimeout</B>()
                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the number of seconds the driver will
 wait for a <code>Statement</code> object to execute.
 If the limit is exceeded, a
 <code>SQLException</code> is thrown.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 To present, HSQLDB always returns zero, meaning there
 is no limit.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getQueryTimeout</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current query timeout limit in seconds; zero means there is
         no limit
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setQueryTimeout(int)"><CODE>setQueryTimeout(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setQueryTimeout(int)"><!-- --></A><H3>
setQueryTimeout</H3>
<PRE>
public void <B>setQueryTimeout</B>(int&nbsp;seconds)
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the number of seconds the driver will wait for a
 <code>Statement</code> object to execute to the given number of seconds.
 If the limit is exceeded, an <code>SQLException</code> is thrown. A JDBC
 (JDBC4 clarification:)
 driver must apply this limit to the <code>execute</code>,
 <code>executeQuery</code> and <code>executeUpdate</code> methods. JDBC driver
 implementations may also apply this limit to <code>ResultSet</code> methods
 (consult your driver vendor documentation for details).
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 The maximum value is Short.MAX_VALUE. The minimum is 0, indicating no limit.
 In 2.0, calls to this method are ignored; HSQLDB waits an
 unlimited amount of time for statement execution
 requests to return.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setQueryTimeout</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>seconds</CODE> - the new query timeout limit in seconds; zero means
        there is no limit
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition seconds >= 0 is not satisfied<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getQueryTimeout()"><CODE>getQueryTimeout()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cancel()"><!-- --></A><H3>
cancel</H3>
<PRE>
public void <B>cancel</B>()
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Cancels this <code>Statement</code> object if both the DBMS and
 driver support aborting an SQL statement.
 This method can be used by one thread to cancel a statement that
 is being executed by another thread.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 2.0, HSQLDB does <i>not</i> support aborting an SQL
 statement; calls to this method are ignored.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>cancel</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support
 this method</DL>
</DD>
</DL>
<HR>

<A NAME="getWarnings()"><!-- --></A><H3>
getWarnings</H3>
<PRE>
public java.sql.SQLWarning <B>getWarnings</B>()
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the first warning reported by calls on this <code>Statement</code> object.
 Subsequent <code>Statement</code> object warnings will be chained to this
 <code>SQLWarning</code> object.

 <p>The warning chain is automatically cleared each time
 a statement is (re)executed. This method may not be called on a closed
 <code>Statement</code> object; doing so will cause an <code>SQLException</code>
 to be thrown.

 <P><B>Note:</B> If you are processing a <code>ResultSet</code> object, any
 warnings associated with reads on that <code>ResultSet</code> object
 will be chained on it rather than on the <code>Statement</code>
 object that produced it.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 From 1.9 HSQLDB, produces Statement warnings.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getWarnings</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the first <code>SQLWarning</code> object or <code>null</code>
         if there are no warnings
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></DL>
</DD>
</DL>
<HR>

<A NAME="clearWarnings()"><!-- --></A><H3>
clearWarnings</H3>
<PRE>
public void <B>clearWarnings</B>()
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Clears all the warnings reported on this <code>Statement</code>
 object. After a call to this method,
 the method <code>getWarnings</code> will return
 <code>null</code> until a new warning is reported for this
 <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Supported in HSQLDB 1.9.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>clearWarnings</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></DL>
</DD>
</DL>
<HR>

<A NAME="setCursorName(java.lang.String)"><!-- --></A><H3>
setCursorName</H3>
<PRE>
public void <B>setCursorName</B>(java.lang.String&nbsp;name)
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the SQL cursor name to the given <code>String</code>, which
 will be used by subsequent <code>Statement</code> object
 <code>execute</code> methods. This name can then be
 used in SQL positioned update or delete statements to identify the
 current row in the <code>ResultSet</code> object generated by this
 statement.  If the database does not support positioned update/delete,
 this method is a noop.  To insure that a cursor has the proper isolation
 level to support updates, the cursor's <code>SELECT</code> statement
 should have the form <code>SELECT FOR UPDATE</code>.  If
 <code>FOR UPDATE</code> is not present, positioned updates may fail.

 <P><B>Note:</B> By definition, the execution of positioned updates and
 deletes must be done by a different <code>Statement</code> object than
 the one that generated the <code>ResultSet</code> object being used for
 positioning. Also, cursor names must be unique within a connection.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 2.0, HSQLDB does not support named cursors;
 calls to this method are ignored.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setCursorName</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the new cursor name, which must be unique within
             a connection
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code>
<DD><CODE>SQLFeatureNotSupportedException</CODE> - if the JDBC driver does not support this method</DL>
</DD>
</DL>
<HR>

<A NAME="getResultSet()"><!-- --></A><H3>
getResultSet</H3>
<PRE>
public java.sql.ResultSet <B>getResultSet</B>()
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
  Retrieves the current result as a <code>ResultSet</code> object.
  This method should be called only once per result.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Without an interceding call to executeXXX, each invocation of this
 method will produce a new, initialized ResultSet instance referring to
 the current result, if any.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getResultSet</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current result as a <code>ResultSet</code> object or
 <code>null</code> if the result is an update count or there are no more results
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute()"><CODE>execute()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getUpdateCount()"><!-- --></A><H3>
getUpdateCount</H3>
<PRE>
public int <B>getUpdateCount</B>()
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
  Retrieves the current result as an update count;
  if the result is a <code>ResultSet</code> object or there are no more results, -1
  is returned. This method should be called only once per result.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getUpdateCount</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current result as an update count; -1 if the current result is a
 <code>ResultSet</code> object or there are no more results
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute()"><CODE>execute()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMoreResults()"><!-- --></A><H3>
getMoreResults</H3>
<PRE>
public boolean <B>getMoreResults</B>()
                       throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Moves to this <code>Statement</code> object's next result, returns
 <code>true</code> if it is a <code>ResultSet</code> object, and
 implicitly closes any current <code>ResultSet</code>
 object(s) obtained with the method <code>getResultSet</code>.

 <P>There are no more results when the following is true:
 <PRE>
     // stmt is a Statement object
     ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1))
 </PRE>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMoreResults</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the next result is a <code>ResultSet</code>
         object; <code>false</code> if it is an update count or there are
         no more results
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#execute()"><CODE>execute()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFetchDirection(int)"><!-- --></A><H3>
setFetchDirection</H3>
<PRE>
public void <B>setFetchDirection</B>(int&nbsp;direction)
                       throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Gives the driver a hint as to the direction in which
 rows will be processed in <code>ResultSet</code>
 objects created using this <code>Statement</code> object.  The
 default value is <code>ResultSet.FETCH_FORWARD</code>.
 <P>
 Note that this method sets the default fetch direction for
 result sets generated by this <code>Statement</code> object.
 Each result set has its own methods for getting and setting
 its own fetch direction.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Up to 1.8.0.x, HSQLDB supports only <code>FETCH_FORWARD</code>;
 Setting any other value would throw an <code>SQLException</code>
 stating that the operation is not supported. <p>

 Starting with 2.0, HSQLDB accepts any valid value.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setFetchDirection</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - the initial direction for processing rows
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
 or the given direction
 is not one of <code>ResultSet.FETCH_FORWARD</code>,
 <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
    for JDBCStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getFetchDirection()"><CODE>getFetchDirection()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFetchDirection()"><!-- --></A><H3>
getFetchDirection</H3>
<PRE>
public int <B>getFetchDirection</B>()
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the direction for fetching rows from
 database tables that is the default for result sets
 generated from this <code>Statement</code> object.
 If this <code>Statement</code> object has not set
 a fetch direction by calling the method <code>setFetchDirection</code>,
 the return value is implementation-specific.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Up to 1.8.0.x, HSQLDB always returned FETCH_FORWARD.

 Starting with 2.0, HSQLDB returns FETCH_FORWARD by default, or
 whatever value has been explicitly assigned by invoking
 <code>setFetchDirection</code>.
 .
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getFetchDirection</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the default fetch direction for result sets generated
          from this <code>Statement</code> object
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
    for JDBCStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setFetchDirection(int)"><CODE>setFetchDirection(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFetchSize(int)"><!-- --></A><H3>
setFetchSize</H3>
<PRE>
public void <B>setFetchSize</B>(int&nbsp;rows)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 (JDBC4 clarification:)
 Gives the JDBC driver a hint as to the number of rows that should
 be fetched from the database when more rows are needed for
 <code>ResultSet</code> objects genrated by this <code>Statement</code>.
 If the value specified is zero, then the hint is ignored.
 The default value is zero.
 <!-- start generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB uses the specified value as a hint, but may process more or fewer
 rows than specified.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setFetchSize</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the number of rows to fetch
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the
        (JDBC4 modified:)
        condition  <code>rows >= 0</code> is not satisfied.<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
   for JDBCStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#getFetchSize()"><CODE>getFetchSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFetchSize()"><!-- --></A><H3>
getFetchSize</H3>
<PRE>
public int <B>getFetchSize</B>()
                 throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the number of result set rows that is the default
 fetch size for <code>ResultSet</code> objects
 generated from this <code>Statement</code> object.
 If this <code>Statement</code> object has not set
 a fetch size by calling the method <code>setFetchSize</code>,
 the return value is implementation-specific.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information</b> <p>

 HSQLDB returns 0 by default, or the fetch size specified by setFetchSize
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getFetchSize</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the default fetch size for result sets generated
          from this <code>Statement</code> object
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
  for JDBCStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setFetchSize(int)"><CODE>setFetchSize(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getResultSetConcurrency()"><!-- --></A><H3>
getResultSetConcurrency</H3>
<PRE>
public int <B>getResultSetConcurrency</B>()
                            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the result set concurrency for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB supports <code>CONCUR_READ_ONLY</code> and
 <code>CONCUR_READ_UPDATEBLE</code> concurrency.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getResultSetConcurrency</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>either <code>ResultSet.CONCUR_READ_ONLY</code> or
 <code>ResultSet.CONCUR_UPDATABLE</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
  for JDBCStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResultSetType()"><!-- --></A><H3>
getResultSetType</H3>
<PRE>
public int <B>getResultSetType</B>()
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the result set type for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB 1.7.0 and later versions support <code>TYPE_FORWARD_ONLY</code>
 and <code>TYPE_SCROLL_INSENSITIVE</code>.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getResultSetType</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
 <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
   for JDBCStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearBatch()"><!-- --></A><H3>
clearBatch</H3>
<PRE>
public void <B>clearBatch</B>()
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Empties this <code>Statement</code> object's current list of
 SQL commands.
 <P>
 (JDBC4 clarification:) <p>
 <B>NOTE:</B>  Support of an ability to batch updates is optional.
 <!-- start generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Starting with HSQLDB 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>clearBatch</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs,
  this method is called on a closed <code>Statement</code> or the
 driver does not support batch updates<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
   for JDBCStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#addBatch()"><CODE>addBatch()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getConnection()"><!-- --></A><H3>
getConnection</H3>
<PRE>
public java.sql.Connection <B>getConnection</B>()
                                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the <code>Connection</code> object
 that produced this <code>Statement</code> object.
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getConnection</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the connection that produced this statement
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or
 this method is called on a closed <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the overview
    for JDBCStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPoolable(boolean)"><!-- --></A><H3>
setPoolable</H3>
<PRE>
public void <B>setPoolable</B>(boolean&nbsp;poolable)
                 throws java.sql.SQLException</PRE>
<DL>
<DD>Requests that a <code>Statement</code> be pooled or not pooled.  The value
 specified is a hint to the statement pool implementation indicating
 whether the application wants the statement to be pooled.  It is up to
 the statement pool manager as to whether the hint is used.
 <p>
 The poolable value of a statement is applicable to both internal
 statement caches implemented by the driver and external statement caches
 implemented by application servers and other applications.
 <p>
 By default, a <code>Statement</code> is not poolable when created, and
 a <code>PreparedStatement</code> and <code>CallableStatement</code>
 are poolable when created.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setPoolable</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>poolable</CODE> - requests that the statement be pooled if true and
                                          that the statement not be pooled if false
 <p>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if this method is called on a closed
 <code>Statement</code>
 <p><DT><B>Since:</B></DT>
  <DD>JDK 1.6 Build 81, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPoolable()"><!-- --></A><H3>
isPoolable</H3>
<PRE>
public boolean <B>isPoolable</B>()
                   throws java.sql.SQLException</PRE>
<DL>
<DD>Returns a  value indicating whether the <code>Statement</code>
 is poolable or not.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>isPoolable</CODE> in interface <CODE>java.sql.Statement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the <code>Statement</code>
 is poolable; <code>false</code> otherwise
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if this method is called on a closed
 <code>Statement</code>
 <p><DT><B>Since:</B></DT>
  <DD>JDK 1.6 Build 81, HSQLDB 2.0
 <p></DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/JDBCPreparedStatement.html#setPoolable(boolean)"><CODE>setPoolable(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.lang.Class)"><!-- --></A><H3>
unwrap</H3>
<PRE>
public &lt;T&gt; T <B>unwrap</B>(java.lang.Class&lt;T&gt;&nbsp;iface)
         throws java.sql.SQLException</PRE>
<DL>
<DD>Returns an object that implements the given interface to allow access to
 non-standard methods, or standard methods not exposed by the proxy.

 If the receiver implements the interface then the result is the receiver
 or a proxy for the receiver. If the receiver is a wrapper
 and the wrapped object implements the interface then the result is the
 wrapped object or a proxy for the wrapped object. Otherwise return the
 the result of calling <code>unwrap</code> recursively on the wrapped object
 or a proxy for that result. If the receiver is not a
 wrapper and does not implement the interface, then an <code>SQLException</code> is thrown.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>unwrap</CODE> in interface <CODE>java.sql.Wrapper</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>iface</CODE> - A Class defining an interface that the result must implement.
<DT><B>Returns:</B><DD>an object that implements the interface. May be a proxy for the actual implementing object.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - If no object found that implements the interface<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isWrapperFor(java.lang.Class)"><!-- --></A><H3>
isWrapperFor</H3>
<PRE>
public boolean <B>isWrapperFor</B>(java.lang.Class&lt;?&gt;&nbsp;iface)
                     throws java.sql.SQLException</PRE>
<DL>
<DD>Returns true if this either implements the interface argument or is directly or indirectly a wrapper
 for an object that does. Returns false otherwise. If this implements the interface then return true,
 else if this is a wrapper then return the result of recursively calling <code>isWrapperFor</code> on the wrapped
 object. If this does not implement the interface and is not a wrapper, return false.
 This method should be implemented as a low-cost operation compared to <code>unwrap</code> so that
 callers can use this method to avoid expensive <code>unwrap</code> calls that may fail. If this method
 returns true then calling <code>unwrap</code> with the same argument should succeed.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>isWrapperFor</CODE> in interface <CODE>java.sql.Wrapper</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>iface</CODE> - a Class defining an interface.
<DT><B>Returns:</B><DD>true if this implements the interface or directly or indirectly wraps an object that does.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if an error occurs while determining whether this is a wrapper
 for an object with the given interface.<DT><B>Since:</B></DT>
  <DD>JDK 1.6, HSQLDB 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="closeOnCompletion()"><!-- --></A><H3>
closeOnCompletion</H3>
<PRE>
public void <B>closeOnCompletion</B>()
                       throws java.sql.SQLException</PRE>
<DL>
<DD>Specifies that this <code>Statement</code> will be closed when all its
 dependent result sets are closed. If execution of the <code>Statement</code>
 does not produce any result sets, this method has no effect.
 <p>
 <strong>Note:</strong> Multiple calls to <code>closeOnCompletion</code> do
 not toggle the effect on this <code>Statement</code>. However, a call to
 <code>closeOnCompletion</code> does effect both the subsequent execution of
 statements, and statements that currently have open, dependent,
 result sets.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if this method is called on a closed
 <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.7 M11 2010/09/10 (b123), HSQLDB 2.0.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isCloseOnCompletion()"><!-- --></A><H3>
isCloseOnCompletion</H3>
<PRE>
public boolean <B>isCloseOnCompletion</B>()
                            throws java.sql.SQLException</PRE>
<DL>
<DD>Returns a value indicating whether this <code>Statement</code> will be
 closed when all its dependent result sets are closed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the <code>Statement</code> will be closed when all
 of its dependent result sets are closed; <code>false</code> otherwise
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if this method is called on a closed
 <code>Statement</code><DT><B>Since:</B></DT>
  <DD>JDK 1.7 M11 2010/09/10 (b123), HSQLDB 2.0.1</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JDBCPreparedStatement.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/hsqldb/jdbc/JDBCParameterMetaData.html" title="class in org.hsqldb.jdbc"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/hsqldb/jdbc/JDBCResultSet.html" title="class in org.hsqldb.jdbc"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/hsqldb/jdbc/JDBCPreparedStatement.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JDBCPreparedStatement.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright  2001 - 2010 HSQL Development Group.</i>
</BODY>
</HTML>
